"use strict";(self.webpackChunklemon_script_documentation=self.webpackChunklemon_script_documentation||[]).push([[2742],{3905:function(e,t,r){r.d(t,{Zo:function(){return c},kt:function(){return d}});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function a(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var p=n.createContext({}),l=function(e){var t=n.useContext(p),r=t;return e&&(r="function"==typeof e?e(t):a(a({},t),e)),r},c=function(e){var t=l(e.components);return n.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,i=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=l(r),d=o,f=m["".concat(p,".").concat(d)]||m[d]||u[d]||i;return r?n.createElement(f,a(a({ref:t},c),{},{components:r})):n.createElement(f,a({ref:t},c))}));function d(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=r.length,a=new Array(i);a[0]=m;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var l=2;l<i;l++)a[l]=r[l];return n.createElement.apply(null,a)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},2368:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return s},contentTitle:function(){return p},metadata:function(){return l},toc:function(){return c},default:function(){return m}});var n=r(7462),o=r(3366),i=(r(7294),r(3905)),a=["components"],s={},p="Order of Operations",l={unversionedId:"documentation/operators/order-of-operations",id:"documentation/operators/order-of-operations",isDocsHomePage:!1,title:"Order of Operations",description:"The order of operations is a rule that tells the correct sequence of steps for evaluating expressions. It is the difference between 5 + 2 * 3 being evaluated as (5 + 2) * 3 instead of 5 * (2 + 3).",source:"@site/docs/documentation/operators/order-of-operations.md",sourceDirName:"documentation/operators",slug:"/documentation/operators/order-of-operations",permalink:"/LemonScript/docs/documentation/operators/order-of-operations",editUrl:"https://github.com/PlebusSupremus1234/LemonScript/website/docs/documentation/operators/order-of-operations.md",version:"current",frontMatter:{},sidebar:"documentation",previous:{title:"Operators",permalink:"/LemonScript/docs/documentation/operators/operators"},next:{title:"Assignment Operators",permalink:"/LemonScript/docs/documentation/operators/assignment-operators"}},c=[{value:"Comparison Operators",id:"comparison-operators",children:[]},{value:"Expression",id:"expression",children:[]}],u={toc:c};function m(e){var t=e.components,r=(0,o.Z)(e,a);return(0,i.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"order-of-operations"},"Order of Operations"),(0,i.kt)("p",null,"The order of operations is a rule that tells the correct sequence of steps for evaluating expressions. It is the difference between ",(0,i.kt)("inlineCode",{parentName:"p"},"5 + 2 * 3")," being evaluated as ",(0,i.kt)("inlineCode",{parentName:"p"},"(5 + 2) * 3")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"5 * (2 + 3)"),". "),(0,i.kt)("h3",{id:"comparison-operators"},"Comparison Operators"),(0,i.kt)("p",null,"Comparison operators compare two ",(0,i.kt)("u",null,"expressions")," with each other, returning a boolean (true/false) value. However, the two expressions have to evaluate to a number or else it will error. For example ",(0,i.kt)("inlineCode",{parentName:"p"},"5 < 6.5")," is valid and would return true, but ",(0,i.kt)("inlineCode",{parentName:"p"},'5 < "hello"')," is invalid because the second type is not a number. "),(0,i.kt)("h3",{id:"expression"},"Expression"),(0,i.kt)("p",null,"An expression is a block of code that evaluates/outputs a value. For example ",(0,i.kt)("inlineCode",{parentName:"p"},"5 + 2 * 3")," is an expression because it returns 11. There are other types of expressions in LemonScript, for example functions and statements, but here, we are going to focus on arithmetic expressions. Arithmetic expressions are evaluated in LemonScript in the same way as in mathematics. You may have heard of PEMDAS or BODMAS. LemonScript follows it. If there's variables in the expression, they will be evaluated first. "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"5 + 5 * 3")," = ",(0,i.kt)("inlineCode",{parentName:"li"},"5 + (5 * 3)")," = ",(0,i.kt)("inlineCode",{parentName:"li"},"20")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"2 ^ (5 + 3)")," = ",(0,i.kt)("inlineCode",{parentName:"li"},"2 ^ 8")," = ",(0,i.kt)("inlineCode",{parentName:"li"},"256")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"8 + 7 % 6 / 3")," = ",(0,i.kt)("inlineCode",{parentName:"li"},"8 + ((7 % 6) / 3)")," = ",(0,i.kt)("inlineCode",{parentName:"li"},"8 + (1 / 3)")," = ",(0,i.kt)("inlineCode",{parentName:"li"},"8.33"))))}m.isMDXComponent=!0}}]);